/*
 * bowl.js v0.1.4
 * (c) 2016-2017 classicemi
 * Released under the MIT license.
 */
!(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = t() : typeof define === 'function' && define.amd ? define(t) : e.Bowl = t() }(this, function () { 'use strict'; function e (e) { return Object.prototype.toString.call(e) === '[object Object]' } function t (e) { return Object.prototype.toString.call(e) === '[object String]' } function n (e) { return Object.prototype.toString.call(e) === '[object Array]' } function r (e) { return /^(https?|\/\/)/.test(e) } function i (t) { let r = null; if (e(t)) { r = {}; for (const o in t) { e(t[o]) || n(t[o]) ? r[o] = i(t[o]) : r[o] = t[o] } } else { n(t) ? (r = [], t.forEach(function (t, o) { return e(t) || n(t) ? void (r[o] = i(t)) : void (r[o] = t) })) : r = t } return r } function o (t, n, r) { if (void 0 === r && (r = !1), e(t) && e(n)) { const o = i(t); for (const c in n) { o.hasOwnProperty(c) ? o[c] = r ? i(n[c]) : o[c] : o[c] = i(n[c]) } return o } } function c (e, t) { let n; const r = /^(https?:\/\/)?([^\/:]+)?:?(\d+)?/; const i = 'http://'; const o = '80'; const c = e.match(r); const u = t.match(r); n = [c[1] ? c[1] : i, c[2] ? c[2] : location.hostname, c[3] ? c[3] : o], c[1] = n[0], c[2] = n[1], c[3] = n[2], u[3] || (u[2] ? u[3] = o : u[3] = c[3]); let s; return s = [u[1] ? u[1] : c[1], u[2] ? u[2] : c[2]], u[1] = s[0], u[2] = s[1], c[0] = '' + c[1] + c[2] + ':' + c[3], u[0] = '' + u[1] + u[2] + ':' + u[3], c[0] !== u[0] } function u (e) { return t(e) ? JSON.parse(p.getItem(e)) : n(e) ? e.map(function (e) { return JSON.parse(p.getItem(e)) }) : void 0 } function s (t, n) { e(n) && p.setItem(t, JSON.stringify(n)) } function a (e) { return t(e) ? p.removeItem(e) : n(e) ? e.forEach(function (e) { return p.removeItem(e) }) : void 0 } const f = window; var p = f.localStorage; const d = function (e) { this.key = e.key, this.url = e.url, this.content = e.content, this.expire = e.expire }; const h = function (e) { this.config = e }; h.prototype.inject = function (e) { const t = this; if (e.noCache) { return this.normalInject(e) } const n = u(e.key); const r = e.ext; const i = (new Date()).getTime(); let o = e.expireAfter ? (new Date()).getTime() + e.expireAfter : null; return o = e.expireWhen ? e.expireWhen : o, e.expire = o, n && e.url === n.url && (!n.expire || i < n.expire) ? new Promise(function (e, i) { try { t.appendToPage(r, n.content), e() } catch (e) { i(e) } }) : new Promise(function (n, i) { t.fetchByXHR(e.url).then(function (i) { e.content = i.content; const o = new d(e); s(o.key, o), t.appendToPage(r, e.content), n() }).catch(function (e) { return i(e) }) }) }, h.prototype.appendToPage = function (e, t) { switch (e) { case 'css':var n = document.createElement('style'); n.textContent = t, document.getElementsByTagName('head')[0].appendChild(n); break; case 'js':var r = document.createElement('script'); r.text = t, r.defer = !0, document.getElementsByTagName('head')[0].appendChild(r) } }, h.prototype.normalInject = function (e) { let t; switch (e.ext) { case 'js':t = new Promise(function (t, n) { const r = document.createElement('script'); r.src = e.url, r.defer = !0, document.getElementsByTagName('body')[0].appendChild(r), r.onload = function () { t() }, r.onerror = function () { n() } }); break; case 'css':t = new Promise(function (t, n) { const r = document.createElement('link'); r.rel = 'stylesheet', r.href = e.url, document.getElementsByTagName('head')[0].appendChild(r), r.onload = function () { t() }, r.onerror = function () { n() } }) } return t }, h.prototype.fetchByXHR = function (e) { const t = new XMLHttpRequest(); const n = new Promise(function (n, r) { t.open('GET', e), t.onreadystatechange = function () { t.readyState === 4 && (t.status === 200 || t.status === 0 && t.responseText ? n({ content: t.responseText }) : r(new Error(t.statusText))) } }); return setTimeout(function () { t.readyState < 4 && t.abort() }, this.config.timeout), t.send(), n }; const l = function (t) { this.vertices = e(t) ? o({}, t) : {} }; l.prototype.addVertex = function (t) { if (!e(this.vertices[t])) { const n = { name: t, prev: 0, next: 0, adjList: [] }; this.vertices[t] = n } }, l.prototype.addEdge = function (e, t) { !this.vertices[e] || !this.vertices[t] || this.vertices[e].adjList.includes(t) || (++this.vertices[e].next, this.vertices[e].adjList.push(t), ++this.vertices[t].prev) }, l.prototype.hasCycle = function () { const e = []; const t = o({}, this.vertices); let n = null; for (const r in t) { t[r].prev === 0 && e.push(t[r]) } for (;e.length > 0;) { n = e.pop(), delete t[n.name], n.adjList.forEach(function (n) { --t[n].prev, t[n].prev === 0 && e.push(t[n]) }) } return Object.keys(t).length > 0 }, l.prototype.getBFS = function () { if (this.hasCycle()) { throw new Error("There are cycles in resource's dependency relations") } for (var e = [], t = new l(this.vertices); Object.keys(t.vertices).length;) { const n = []; for (const r in t.vertices) { t.vertices[r].prev === 0 && n.push(r) } n.length && (e.push(n), n.forEach(function (e) { t.vertices[e].adjList.forEach(function (e) { --t.vertices[e].prev }), delete t.vertices[e] })) } return e }; const v = window; const g = 'bowl-'; const y = v.localStorage && v.Promise; const m = function () { this.config = { timeout: 6e4, expireAfter: null, expireWhen: null }; const e = []; Object.defineProperty(this, 'ingredients', { __proto__: null, configurable: !0, get () { return e } }), this.injector = new h(this.config) }; return m.prototype.configure = function (e) { this.config = o(this.config, e, !0) }, m.prototype.add = function (t) { const i = this; if (!n(t)) { if (!e(t)) { return } t = [t] } const u = function (e) { const t = o(i.config, e, !0); const n = {}; const u = ((new Date()).getTime(), r(t.url)); const s = /\.(\w+)(\?.+)?$/i; n.key = '' + g + (t.key || t.url), n.expireAfter = t.expireAfter, n.expireWhen = t.expireWhen, n.url = u ? t.url : v.location.origin + '/' + t.url.replace(new RegExp('^/*'), ''), y ? (n.noCache = !!t.noCache, c(v.location.origin, n.url) && (n.noCache = !0)) : n.noCache = !0; const a = n.url.match(s); return n.ext = a ? a[1] : a, n.dependencies = t.dependencies, n }; const s = function (e) { if (!e.key || !/^[a-zA-z0-9_]+$/.test(e.key)) { throw new Error('invalid key of bowl ingredient') } if (!e.url) { throw new Error('no valid url of bowl ingredient') } const t = u(e); const n = i.ingredients.findIndex(function (e) { return e.key === t.key }); return n > -1 ? void i.ingredients.splice(n, 1, t) : void i.ingredients.push(t) }; t.forEach(function (e) { return s(e) }) }, m.prototype.inject = function () { const e = this; if (!this.ingredients.length) { return Promise.resolve() } const t = new l(); this.ingredients.forEach(function (e) { return t.addVertex(e.key) }), this.ingredients.forEach(function (e) { e.dependencies && e.dependencies.length && e.dependencies.forEach(function (n) { t.addEdge('' + g + n, e.key) }) }); const n = t.getBFS(); const r = function (t) { const n = []; return t.forEach(function (t) { n.push(e.injector.inject(e.ingredients.find(function (e) { return e.key === t }))) }), Promise.all(n) }; let i = Promise.resolve(); return n.forEach(function (e) { i = i.then(function () { return r(e) }) }), i }, m.prototype.remove = function (e) { const r = this; if (!e) { const i = this.ingredients.map(function (e) { return e.key.replace(new RegExp('^' + g, 'i'), '') }); return void i.forEach(function (e) { return r.remove(e) }) } if (t(e)) { const o = '' + g + e; const c = this.ingredients.findIndex(function (e) { return e.key === o }); this.ingredients.splice(c, 1), a(o) } else if (n(e)) { '' + g + (e.key ? e.key : e.url ? e.url : ''); return void e.forEach(function (e) { return r.remove(e) }) } }, m }))
